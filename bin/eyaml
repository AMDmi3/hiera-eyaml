#!/usr/bin/env ruby

require 'openssl'
require 'base64'
require 'trollop'
require 'highline/import'
require 'hiera/backend/version'

def ensureKeyDirExists(key_file)
  key_dir = File.dirname(key_file)

  if !File.directory?(key_dir)
    Dir.mkdir(key_dir)
    puts "Created #{key_dir} dir for #{key_file}."
  end
end

def getFileInput(options)
  if options[:file]
    return File.read( options[:file] )
  else
    return STDIN.read
  end
end

def getInput(options)
  return options[:string] if options[:string]

  if options[:password]
    password = ask("Enter password: ") {|q| q.echo = "*" }
    return password
  end

  getFileInput(options)
end

def encrypt(public_key, plaintext)
  cipher = OpenSSL::Cipher::AES.new(256, :CBC)
  ciphertext_binary = OpenSSL::PKCS7::encrypt([public_key], plaintext, cipher, OpenSSL::PKCS7::BINARY).to_der
  Base64.encode64(ciphertext_binary).strip
end

def decrypt(public_key, private_key, ciphertext)
    ciphertext_decoded = Base64.decode64(ciphertext)
    pkcs7 = OpenSSL::PKCS7.new( ciphertext_decoded )
    pkcs7.decrypt(private_key, public_key)
end


options = Trollop::options do
    
  version "Hiera-eyaml version " + Hiera::Backend::Eyaml::VERSION.to_s
  banner <<-EOS
Hiera-eyaml is a backend for Hiera which provides OpenSSL encryption/decryption for Hiera properties

Usage:
  eyaml [options] [string-to-encrypt]
  EOS
  
  opt :createkeys, "Create public and private keys for use encrypting properties", :short => 'c'
  opt :encrypt, "Encrypt something"
  opt :decrypt, "Decrypt something"
  opt :eyaml, "Assume input is eyaml format"
  opt :password, "Encrypt a password entered on the terminal", :short => 'p'
  opt :string, "Encrypt a string provided on the command line", :short => 's', :type => :string 
  opt :private_key, "Filename of the private_key", :type => :string, :default => "/etc/hiera/keys/private_key.pem"
  opt :public_key, "Filename of the public_key", :type => :string, :default => "/etc/hiera/keys/public_key.pem"
  opt :output, "Output mode to use when encrypting (examples, block or string)", :type => :string, :default => "examples"
end

main_option_count = 0
main_option_count += 1 if options[:createkeys]
main_option_count += 1 if options[:encrypt]
main_option_count += 1 if options[:decrypt]
main_option_count += 1 if options[:edit]

Trollop::die "You can only specify one main action" if main_option_count > 1
Trollop::die "You cannot specify --password and --string" if options[:password] and options[:string]

options[:file] = ARGV[0]
if options[:file] and (options[:password] or options[:string])
  $stderr.puts "WARN: file supplied but will be shadowed by string or password"
end

if options[:createkeys]

  # Try to do equivalent of:
  # openssl req -x509 -nodes -days 100000 -newkey rsa:2048 -keyout privatekey.pem -out publickey.pem -subj '/'

  ensureKeyDirExists(options[:private_key])
  ensureKeyDirExists(options[:public_key])

  key = OpenSSL::PKey::RSA.new(2048)
  open( options[:private_key], "w" ) do |io|
    io.write(key.to_pem)
  end

  $stderr.puts "#{options[:private_key]} created."

  name = OpenSSL::X509::Name.parse("/")
  cert = OpenSSL::X509::Certificate.new()
  cert.serial = 0
  cert.version = 2
  cert.not_before = Time.now
  cert.not_after = Time.now + 50 * 365 * 24 * 60 * 60
  cert.public_key = key.public_key

  ef = OpenSSL::X509::ExtensionFactory.new
  ef.subject_certificate = cert
  ef.issuer_certificate = cert
  cert.extensions = [
    ef.create_extension("basicConstraints","CA:TRUE", true),
    ef.create_extension("subjectKeyIdentifier", "hash"),
    # ef.create_extension("keyUsage", "cRLSign,keyCertSign", true),
  ]
  cert.add_extension ef.create_extension("authorityKeyIdentifier",
                                         "keyid:always,issuer:always")

  cert.sign key, OpenSSL::Digest::SHA1.new

  open( options[:public_key], "w" ) do |io|
    io.write(cert.to_pem)
  end
  $stderr.puts "#{options[:public_key]} created."
  exit
end

if not options[:eyaml]
  if options[:encrypt]

    plaintext = getInput(options)

    if plaintext.nil? or plaintext.length == 0
      $stderr.puts "Specify a string or --file to encrypt something. See --help for more usage instructions."
      exit
    end

    public_key_pem = File.read( options[:public_key] )
    public_key = OpenSSL::X509::Certificate.new( public_key_pem )
    
    ciphertext_as_block = encrypt(public_key, plaintext)
    ciphertext_as_string = ciphertext_as_block.split("\n").join('')

    case options[:output]
    when "examples"
      puts "string: ENC[#{ciphertext_as_string}]\n\nOR\n\n"
      puts "block: >"
      puts "    ENC[" + ciphertext_as_block.gsub(/\n/, "\n    ") + "]"
    when "block"
      puts "ENC[" + ciphertext_as_block + "]"
    when "string"
      puts "ENC[#{ciphertext_as_string}]"
    else
      $stderr.puts "Unknown output option: " + options[:output]
      exit 1
    end
    exit

  end

  if options[:decrypt]

    ciphertext = getInput(options)
    if ciphertext.nil? or ciphertext.length == 0
      $stderr.puts "Specify a string or --file to decrypt something. See --help for more usage instructions."
      exit 1
    end

    if ciphertext.start_with? "ENC["

      ciphertext = ciphertext[4..-2]

      private_key_pem = File.read( options[:private_key] )
      private_key = OpenSSL::PKey::RSA.new( private_key_pem )

      public_key_pem = File.read( options[:public_key] )
      public_key = OpenSSL::X509::Certificate.new( public_key_pem )

      plaintext = decrypt(public_key, private_key, ciphertext)
      puts "#{plaintext}"
      exit

    else

      $stderr.puts "Ciphertext is not an eyaml encrypted string (Does not start with ENC[...])"
      exit 1

    end

    exit

  end
end

if options[:eyaml]
  if options[:decrypt]
    encrypted_block_regex = />\n( *)ENC\[([a-zA-Z0-9+\/ \n]+)\]/
    encrypted_string_regex = /ENC\[([a-zA-Z0-9+\/]+)\]/

    # prepare to decrypt blocks
    private_key_pem = File.read( options[:private_key] )
    private_key = OpenSSL::PKey::RSA.new( private_key_pem )

    public_key_pem = File.read( options[:public_key] )
    public_key = OpenSSL::X509::Certificate.new( public_key_pem )

    eyaml = getFileInput(options)

    # decrypt blocks first
    eyaml = eyaml.gsub(encrypted_block_regex) { |match|
      indentation = $1
      ciphertext = $2.gsub(/[ \n]/, '')
      plaintext = decrypt(public_key, private_key, ciphertext)
      ">\n"+indentation+"ENC![" + plaintext + "]!ENC"
    }

    # then decrypt strings
    eyaml = eyaml.gsub(encrypted_string_regex) { |match|
      plaintext = decrypt(public_key, private_key, $1)
      "ENC![" + plaintext + "]!ENC"
    }

    puts eyaml
    exit
  end

  if options[:encrypt]
    decrypted_block = />\n( *)ENC!\[(.+)\]!ENC/
    decrypted_string = /ENC!\[(.+)\]!ENC/

    # prepare to encrypt blocks
    public_key_pem = File.read( options[:public_key] )
    public_key = OpenSSL::X509::Certificate.new( public_key_pem )

    eyaml = getFileInput(options)

    # encrypt blocks
    eyaml = eyaml.gsub(decrypted_block) { |match|
      indentation = $1
      ciphertext = encrypt(public_key, $2).gsub(/\n/,"\n"+indentation)
      ">\n" + indentation + "ENC[" + ciphertext + "]"
    }
    # encrypt strings
    eyaml = eyaml.gsub(decrypted_string) { |match|
      ciphertext = encrypt(public_key, $1).gsub(/\n/,'')
      "ENC[" + ciphertext + "]"
    }
    
    puts eyaml
    exit
  end
end
